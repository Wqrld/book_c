\chapter{Het compilatieproces}
\label{cha:compilatieproces}
\thispagestyle{empty}

De compiler is een ingewikkeld stuk gereedschap. Het compileert C-bestanden, voegt ze samen, ``plakt'' er bibliotheken met vooraf geprogrammeerde functies aan vast en zorgt ervoor dat uiteindelijk een uitvoerbaar bestand\index{uitvoerbaar bestand} of \textsl{executable}\index{executable} wordt gegenereerd. Dit uitvoerbaar bestand bevat de instructies die door de computer kunnen worden uitgevoerd.

In dit hoofdstuk zullen we enige aspecten van het compilatieproces bespreken. Hoewel er veel verschillende C-compilers bestaan, volgen de C-compilers min of meer dezelfde lijn als het om compilatie van bestanden gaat. We zullen ons richten op een veelgebruikte C-compiler, namelijk de GNU C-compiler. Deze compiler wordt veel gebruikt, met name in de markt van microcontrollers. Deze compiler is geschikt voor onder andere de PC of laptop (Windows en Linux), de ATmega-microcontrollers, de STM32-microcontrollers en de MSP430-microcontrollers. Natuurlijk wordt alles geregeld door de Integrated Development Environment\index{Integrated Development Environment} (IDE)\index{IDE} en hoeft de gebruiker niet zelf alle commando's te geven. We doen dat in dit hoofdstuk wel, om te laten zien wat er nou eigenlijk gebeurt.


\section{Een C-programma in één bestand}
De meeste kleine C-programma's worden in één bestand georganiseerd. We compileren het en daarna kan het op de computer worden uitgevoerd. Maar ``onder de motorkap`` gebeuren toch nog wel wat dingen. Laten we eens kijken hoe de C-compiler gestart wordt. We geven de opdracht (op de command line):

\hspace*{1em}\texttt{gcc mooi.c -o mooi.exe}

Als alles goed verloopt, wordt er een uitvoerbaar bestand \texttt{mooi.exe} gegenereerd\footnote{Op Unix-systemen, dus ook Linux en OS-X, heeft een uitvoerbaar bestand geen extensie. De compilatie-opdracht wordt dan \texttt{gcc mooi.c -o mooi}, waarna we \texttt{mooi} kunnen uitvoeren.}. We kunnen dit bestand uitvoeren met \texttt{.\textbackslash mooi.exe}. Soms kan de \texttt{.\textbackslash} weggelaten worden, afhankelijk van de instellingen van Windows.


\section{Een C-programma in meerdere bestanden}
Een groot C-programma kunnen we onderverdelen in meerdere C-bestanden. Dit heeft een aantal voordelen. Ten eerste kunnen we veel gebruikte programmadelen, denk hierbij aan functies, afzonderen van het grote geheel. We kunnen deze functies zo opstellen dat ze door meerdere programma's gebruikt kunnen worden. Dit is goed voor de \textsl{herbruikbaarheid}. Ten tweede kunnen we de ontwikkeling van het programma makkelijk verdelen onder meerdere personen. Dit is goed voor de \textsl{verantwoordelijkheid} van onderdelen van het programma. 

Tijdens compilatie moeten alle C-bestanden gecompileerd worden om uiteindelijk een uitvoerbaar bestand te krijgen. Stel dat we ons C-programma verdelen over meerdere bestanden (dit worden \textsl{translation units}\index{translation unit} genoemd). Dan kunnen we de C-compiler aanroepen met:

\hspace*{1em}\texttt{gcc file1.c file2.c file3.c -o programma.exe}

Alle C-bestanden worden gecompileerd en uiteindelijk samengevoegd tot het uitvoerbare bestand \texttt{programma.exe}.
Als er in een van de C-bestanden een fout zit, moet die hersteld worden en moeten alle C-programma's opnieuw gecompileerd worden op de bovenstaande wijze.

Merk op dat eventuele header-bestanden niet aan de C-compiler opgegeven worden. De header-bestanden worden tijdens compilatie van een C-bestand ingelezen door de compiler.

\section{Assembler-bestanden}
Soms is het nodig om bepaalde code te programmeren in \textit{assembly}\index{assembly}. Assembly is een taal die zeer dicht tegen de gebruikte processor ligt. Te denken valt aan code die niet in C geschreven kan worden, zoals opstartcode van het C-programma.

Een assembler-bestand\index{assembler-bestand} heeft meestal de extensie \texttt{.s}, soms ook wel \texttt{.asm}. We kunnen de C-compiler vragen om een assembler-bestand te compileren:

\hspace*{1em}\texttt{gcc file.s -o programma.exe}

Meestal wordt een assembler-bestand samen met C-bestanden gecompileerd:

\hspace*{1em}\texttt{gcc file1.c file2.c startup.s -o programma.exe}


%dan wordt elk van de C-bestanden gecompileerd naar een \textsl{objectbestand}\index{object-bestand} en worden deze objectbestanden uiteindelijk samengevoegd tot het uitvoerbare bestand \texttt{programma.exe}.


\section{Stappen in de compilatie}
De compilatie van een programma gebeurt in een aantal stappen. Deze zijn in een schematisch overzicht in figuur~\ref{fig:comschematisch} te zien.

\begin{sidewaysfigure}[!p]
\centering
\begin{tikzpicture}[font=\sffamily,scale=0.65] 

\draw (0,0) rectangle (2,2);\node at (1,1) {PRE};
\draw (0,-3) rectangle (2,-1);\node at (1,-2) {PRE};

\draw (4,0) rectangle (7,2);\node at (5.5,1) {C};
\draw (4,-3) rectangle (7,-1); \node at (5.5,-2) {C};

\draw (8.5,0) rectangle (11.5,2);\node at (10,1) {AS};
\draw (8.5,-3) rectangle (11.5,-1);\node at (10,-2) {AS};
\draw (8.5,-6) rectangle (11.5,-4);\node at (10,-5) {AS};

\draw (15,2) rectangle (18,-10);\node at (16.5,-3) {LINKER};

\draw[dashed] (22,0) rectangle (25,-8) node[midway] {POST};

\node[left] at (-2,1) {file1.c}; 
\node[left] at (-2,-2) {file2.c}; 
\node[left] at (-2,-5) {file3.s}; 
\node[left] at (-2,-8) {libc.a}; 
\node[left] at (-2,-9) {libm.a}; 

\draw[-latex] (-2,1) -- (0,1);
\draw[-latex] (-2,-2) -- (0,-2);

\draw[-latex] (2,1) -- (4,1);
\draw[-latex] (2,-2) -- (4,-2);
\draw[-latex] (-2,-5) -- (8.5,-5);
\draw[-latex] (7,1) -- (8.5,1);
\draw[-latex] (7,-2) -- (8.5,-2);


\draw[-latex] (-2,-8) -- (15,-8);
\draw[-latex] (-2,-9) -- (15,-9);

\draw[-latex] (18,-5) -- ++(2,0) -- ++(0,-2) node[below] {prog.exe};
\draw[-latex] (18,-4) -- ++(4,0) node[midway,above] {prog.elf};

\draw[-latex] (11.5,1) -- (15,1) node[midway,above] {file1.o};
\draw[-latex] (11.5,-2) -- (15,-2) node[midway,above] {file2.o};
\draw[-latex] (11.5,-5) -- (15,-5) node[midway,above] {file3.o};

\draw[-latex] (25,-4) -- ++(2,0) node[right] {prog.hex};
\end{tikzpicture}
\caption{Schematisch overzicht van een compilatie.}
\label{fig:comschematisch}
\end{sidewaysfigure}

Het \texttt{gcc}-programma is niet de echte compiler maar meer een programma dat een vertaler is tussen de gebruiker en andere programma's. \texttt{gcc} verzamelt bestandsnamen en opties en start dan de benodigde programma's met opties.

Een C-bestand wordt in drie stappen gecompileerd. Eerst wordt het C-bestand aan de \textsl{preprocessor} (PRE) doorgegeven (zie hoofdstuk~\ref{cha:preprocessor}). De uitvoer is een een tijdelijk bestand. Dit is eigenlijk geen echte compilatie want er worden alleen \textsl{macro's}\index{macro} verwerkt. Daarna wordt dit tijdelijke bestand aan de ``echte'' C-compiler doorgegeven. De C-compiler genereert een \textsl{assembler-bestand} met daarin de instructies voor de gekozen processor. De \textsl{assembler} (AS) assembleert dit bestand en genereert een \textsl{object-bestand}\index{object-bestand}. In het object-bestand zijn de bitpatronen van de instucties opgeslagen, maar het kan zijn dat bepaalde \textsl{referenties} naar functies en globale variabelen nog niet zijn ingevuld. Denk hierbij aan de \texttt{printf}-functie die we niet zelf geschreven hebben maar in een \textsl{bibliotheek}\index{library}\index{bibliotheek} is opgeslagen. Een assembler-bestand wordt direct door de assembler geassembleerd.

Alle gegenereerde object-bestanden worden aan de \textsl{linker}\index{linker} doorgegeven, die de object-bestanden samenvoegt met functies en globale variabelen uit de bibliotheken. Daarna wordt een uitvoerbaar programma gegenereerd.

Als we een programma ontwikkelen voor een microcontroller (dat wordt \textsl{cross-compiling} genoemd, omdat de compiler instructies genereert voor een andere processor), volgt vaak nog een \textsl{post-processing}-stap. Deze stap is nodig om een bestand te genereren dat met behulp van een \textsl{programmer} in de microcontroller kan worden geladen.


Twee veel gebruikte bibliotheken zijn de \textsl{standard library}\index{standard library} en de \textsl{mathematical library}\index{mathematical libray}. De standard library heeft de naam \texttt{libc.a} (bij de GNU C-compiler onder de naam \texttt{glibc.a}). De extensie \texttt{.a} (\textsl{archive}) geeft aan dat het om een bibliotheek gaat. De mathematical library heeft de naam \texttt{libm.a} en moet in veel gevallen expliciet worden opgegeven:

\hspace*{1em}\texttt{gcc file1.c -l m -o programma.exe}

Merk op dat de standard library niet expliciet moet worden opgegeven. De C-compiler regelt dat automatisch.

Een bibliotheek is eigenlijk een verzameling van object-bestanden. Tijdens het linken worden uit de bibliotheek alleen de object-bestanden meegenomen die nodig zijn. De overige object-bestanden worden dus niet meegenomen. Het is namelijk geen zin om de functie \texttt{strlen} erbij te voegen als de functie niet aangeroepen wordt.


\section{Bibliotheek maken}
Het is ook mogelijk om een bibliotheek te maken. Daarvoor moet een C-bestand gecompileerd worden naar een object-bestand:

\hspace*{1em}\texttt{gcc -c file1.c -o file1.o}\\
\hspace*{1em}\texttt{gcc -c file2.c -o file2.o}\\
\hspace*{1em}\texttt{gcc -c file3.c -o file3.o}

Daarna moet de \textsl{archiver} gestart worden:

\hspace*{1em}\texttt{ar rcs libmy.a file1.o file2.o file3.o}

De bibliotheek is nu te linken met:

\hspace*{1em}\texttt{gcc file.c -l my -o programma.exe}

Er bestaat op veel besturingssystemen zoiets als \textsl{shared libraries}. Dit zijn bibliotheken die eenmalig in het geheugen van de computer worden geladen waarna ze gebruikt kunnen worden door programma's. Pas op het moment dat een programma wordt gestart, worden de referenties naar functies en externe variabelen ingevuld. Dit wordt \textsl{dynamic linking} genoemd. Een voorbeeld zijn \textsl{dynamic link libraries} (DLL) op Windows.


\section{Optimalisatie}
Zoals al eerder is vermeld, is de C-compiler een ingewikkeld programma\footnote{De vraag is altijd: in welke taal is de C-compiler geschreven? Het antwoord is: in C zelf. Dit levert natuurlijk het kip-en-ei-probleem. Het antwoord is dat de C-compiler in eerste instantie in assembly is geschreven en vandaar uit is een echte C-compiler gebouwd. Opvolgende generaties van C-compilers kunnen dus gecompileerd worden door (oudere) C-compilers.}. De huidige C-compilers zijn zeer pienter in het herkennen van de C-taal. Laten we eens kijken naar het programma in listing~\ref{cod:comclearary}.

\begin{lstlisting}[caption=Een C-programma.,label=cod:comclearary]
#include <stdio.h>

int main(void) {

    int ary[1000], i;
    
    for (i = 0; i < 1000; i++) {
        ary[i] = 0;
    }
    // ...
    
    return 0;
}
\end{lstlisting}

In principe alloceert de compiler 1000 integers voor array \texttt{ary} en een integer voor \texttt{i}. Maar de compiler heeft door dat \texttt{i} gebruikt wordt als lusvariabele. Het is dan beter om deze variabele niet in het geheugen van de computer op te slaan maar vast te houden in een \textsl{register}. Een register is een speciale geheugenplaats in de processor. Alle processoren hebben een aantal van deze registers. Als variabele \texttt{i} nu in een register wordt opgeslagen dan hoeft de processor \texttt{i} niet steeds uit het geheugen te halen. Daardoor wordt de executie van het \texttt{for}-statement sneller. Het gevolg is dat voor variabele \texttt{i} helemaal geen geheugenplaats wordt gereserveerd. We kunnen aan de C-compiler opgeven dat een bepaalde variabele beter in een register kan worden opgeslagen met het keyword \texttt{register}\indexkeyword{register}:

\hspace*{1em}\texttt{register int i;}

Overigens staat het de compiler vrij om \texttt{register} te negeren. Over het algemeen weet de compiler beter welke variabelen in registers moeten worden gehouden. Het gebruik van register wordt daarom niet aanbevolen.

\begin{figure}[!ht]
\begin{lstlisting}[caption=Een C-programma.,label=cod:comnothing]
#include <stdio.h>

int main(void) {

    int i;
    
    for (i = 0; i < 30000; i++) {
        // do nothing, just waste processor time
    }
    
    return 0;
}
\end{lstlisting}
\end{figure}

Een ander voorbeeld is een \texttt{for}-statement waarin ogenschijnlijk niets gebeurt. Dit is te zien in listing~\ref{cod:comnothing}.
Dit soort herhalingen worden nog wel eens gebruikt als er in een programma een tijdje moet worden gewacht. Als we naar het \texttt{for}-statement kijken, gebeurt er eigenlijk niets, behalve dat variabele \texttt{i} wordt opgehoogd. De C-compiler kan nu beslissen om het hele \texttt{for}-statement te verwijderen want, zo is de gedachte, er gebeurt toch niets. Willen we ervoor zorgen dat het \texttt{for}-statement toch wordt gebruikt dan kunnen we een variabele voorzien van het keyword \texttt{volatile}\indexkeyword{volatile}:

\newpage
\hspace*{1em}\texttt{volatile int i};

Het keyword \texttt{volatile} betekent zoiets als: gebruik variabele \texttt{i} ook al lijkt er niets zinnigs mee te gebeuren. De C-compiler zal hierdoor over het algemeen wel een geheugenplaats voor \texttt{i} realiseren; \texttt{i} wordt dan niet in een register vastgehouden.

De compiler kent nog vele optimalisatiemogelijkheden. We beschrijven er nog één: loop unrolling. Zie listing~\ref{cod:comloopunroll}.

\begin{figure}[!ht]
\begin{lstlisting}[caption=Een C-programma.,label=cod:comloopunroll]
#include <stdio.h>

int main(void) {

    int ary[4], i;
    
    for (i = 0; i < 4; i++) {
        ary[i] = 0;
    }
    
    return 0;
}
\end{lstlisting}
\end{figure}

De compiler kan beslissen of het wenselijk is om het \texttt{for}-statement om te zetten naar vier toekenningen. Dat is sneller dan een lus op te zetten. Dus wordt het \texttt{for}-statement omgezet naar:

\hspace*{1em}\texttt{ary[0] = 0; ary[1] = 0; ary[2] = 0; ary[3] = 0;}

