\chapter{Structures}
\label{cha:structures}
\thispagestyle{empty}

Een structuur (Engels: structure)\footnote{We zullen vanaf nu de Engelse naam structure gebruiken.} is een verzameling bij elkaar behorende gegevens beschikbaar onder één enkele naam. Dit is vooral handig bij complexe \textsl{datasturcturen} want ze helpen om gerelateerde variabelen als een eenheid te bewerken in plaats van een aantal verschillende variabelen. Structures komen overeen met een \textsl{rij} in een relationele database. Een bekend voorbeeld is de loonlijst van werknemers. Een werknemer heeft een naam, een adres, een salaris en een functie.

Structures kunnen gezien worden als één enkele variabele. Zo mogen we structures eenvoudig kopiëren met een toekenning, we mogen ze meegeven als argumenten aan een functie, een functie kan een structure in zijn geheel teruggeven, we kunnen het adres van een structure opvragen met de adres-operatore \texttt{\&} en we mogen de variabelen binnen de structure gebruiken in expressie. We mogen \textsl{niet} twee structures vergelijken.

\section{Definitie en declaratie}

Een welhaast klassiek voorbeeld van een structure is een aantal artikelen. Van de artikelen geven we het artikelnummer, de naam, het aantal dat beschikbaar is en de prijs per stuk op. We definiëren de structure \texttt{artikel} als volgt:

% We gebruiken label=cod:struct1 om de standaard label te wijzigen
\booklisting[linerange={6-11},label=cod:struct1]{C}{De structure \texttt{artikel}}{struct_artikel}{c}{H}

De variabelen binnen de structure worden \textsl{leden} genoemd maar we zullen gebruik maken van de Engelse naam \textsl{members}\index{member}\index{structure!member}\indexkeyword{struct}.

We kunnen nu de structure gebruiken in declaraties door gebruik te maken van

\hspace*{1em}\texttt{struct artikel} \textsl{variabele};

om variabelen te declareren. In listing~\ref{cod:struct2} is een aantal declaraties te zien:\textbf{}

\booklisting[linerange={40-43},label=cod:struct2]{C}{Declaratie van enkele variabelen}{struct_artikel}{c}{H}

In regel 1 wordt de variabele \texttt{floppy} gedeclareerd zonder initialisatie. We kunnen bij declaratie gelijk de members initialiseren zoals te zien is in regels 3 en 4.  In de initialisatielijst moet natuurlijk wel de juiste datatypes gebruikt worden, tenzij automatische conversie mogelijk is. Structures mogen zowel globaal als lokaal worden gedeclareerd.

\section{Toegang tot members}
Om gebruik te maken van een member gebruiken we de \textsl{member operator} \texttt{.}\indexop{.} (punt). Om de prijs van het artikel \texttt{floppy} in te stellen kunnen we bijvoorbeeld gebruiken:

\hspace*{1em}\texttt{floppy.prijs = 10.73;}

Om het aantal af te drukken gebruiken we \texttt{printf} met de member \texttt{aantal}:

\hspace*{1em}\texttt{printf("Aantal beschikbaar is \%d", floppy.aantal);}

Om het aantal beschikbare exemplaren van een artikel te verhogen kunnen we de member \texttt{aantal} verhogen:

\hspace*{1em}\texttt{floppy.aantal += 5; \ \ // 5 exemplaren erbij}

Let erop dat de naam van een artikel een \textsl{string} is. Om de naam aan te passen moeten we gebruik maken van de functie \texttt{strcpy}\indexfunc{strcpy}:

\hspace*{1em}\texttt{strcpy(floppy.naam, "Floppy 3.5 in");}

\section{Functies met structures}
Stel dat we de gegevens van een artikel willen afdrukken. Dan kunnen we natuurlijk alle members apart afdrukken. Maar is het handiger om een functie te definiëren die dat voor ons doet. Een structure mag gewoon als parameter aan een functie worden weergegeven\index{structure!als argument}\index{structure!als parameter}. In de functie kunnen we dan de members een voor een afdrukken. Dit is te zien in listing~\ref{cod:struct3}. Binnen de functie drukken we de members een voor een af. We hebben extra spaties toegevoegd om de gegevens netjes van elkaar te scheiden.

\booklisting[linerange={13-18},label=cod:struct3]{C}{Afdrukken van de gegevens van een  artikel}{struct_artikel}{c}{H}

Als we een nieuw artikel willen toevoegen, kunnen we alle members van de structure een waarde toekennen. Maar het is gemakkelijker om een functie te definiëren die dat voor ons doet. Een mogelijke functie is te zien in listing~\ref{cod:struct4}.

\booklisting[linerange={20-30},label=cod:struct4]{C}{Aanmaken van een nieuw artikel}{struct_artikel}{c}{H}

De parameters krijgen de waarden mee die aan de members moeten worden toegekend. Om een nieuwe structure te maken waar de gegeven inkomen, declareren we in regel 3 een structure met de naam \texttt{nieuw}. We moeten daarna een voor een de waarden aan de members toekennen. Vervolgens geven we de gehele structure terug aan de aanroepen

We kunnen de structure \texttt{floppy} bijvoorbeeld initialiseren met:

\hspace*{1em}\texttt{floppy = maak\_artikel(7, "Floppy", 5, 10.73);}

\section{Typedef}
\index{structure!typedef}
Met behulp van het keyword \texttt{typedef}\indexkeyword{typedef} kunnen we een structure beschikbaar stellen onder een eigen datatype. Zo kunnen we het nieuwe type \texttt{artikel\_t} aanmaken met de definitie in listing~\ref{cod:struct11}. Let erop dat \texttt{artikel\_t} geen echt nieuw datatype is, het is meer een synoniem. Het blijft onder alle omstandigheden een structure. We mogen dan ook de naam na \texttt{struct} achterwege laten. Merk op dat de definitie van de oorspronkelijke structure tussen \texttt{typedef} en \texttt{artikel\_t} staat.

\booklisting[linerange={6-11},label=cod:struct11]{C}{De definitie van datatype \texttt{artikel\_t}}{struct_artikel_typedef}{c}{H}

Vervolgens kunnen we variabelen declareren met de \texttt{typedef}:

\hspace*{1em}\texttt{artikel\_t floppy, sdcard, usbstick;}

We kunnen \texttt{typedef} ook gebruiken bij andere datatypes:

\hspace*{1em}\texttt{typedef unsigned long int ulint;}

\texttt{Typedef}'s zijn handig om een programma onafhankelijke te maken van de C-compiler die gebruikt wordt en de computer waarop het programma draait. Als een programma verplaatst wordt naar een andere computer (dat wordt \textsl{porteren} genoemd), hoeven alleen de \texttt{typedef}'s te worden aangepast. Daarna kan het programma gecompileerd worden met de nieuwe \texttt{typedef}'s.

\section{Pointers naar structures}
\index{structure!pointer naar}\index{pointer!naar structure}
Als een structure een groot aantal members bevat, is het niet handig om een hele structure aan een functie mee te geven als parameters. Een argument dat wordt meegegeven wordt namelijk gekopieerd naar de parameters. Het is dan beter om een pointer naar een structure mee te geven. Bijkomend voordeel (of is het een probleem) is dat ook gelijk de members van de structure kunnen worden aangepast. Als we willen dat een argument niet kan worden aangepast, gebruiken we het keyword \texttt{const}\indexkeyword{const} bij de parameterdeclaratie. De compiler ziet er dan op toe dat in de functie geen members worden aangepast. Zie listing~\ref{cod:struct12} voor de functie voor het afdrukken van gegevens van een artikel.

\booklisting[linerange={13-18},label=cod:struct12,escapeinside={{}{}}]{C}{Een functie om de gegevens van een artikel af te drukken}{struct_artikel_typedef}{c}{H}

In regel 1 wordt een pointer naar een structure \texttt{artikel} gedeclareerd. Let op het keyword \texttt{const} dat aangeeft dat in de functie de members niet worden aangepast. In regel 2 is te zien hoe het artikelnummer wordt afgedrukt. Let hierbij op de haakjes om de pointervariabele. Die zijn nodig omdat de member operator \texttt{.} (punt) een hogere prioriteit heeft dan de dereferentie-operator \texttt{*}. Dus:

\hspace*{1em}\texttt{(*a).nummer}

selecteert member \texttt{nummer} van de structure die aangewezen wordt door pointer \texttt{a} terwijl

\hspace*{1em}\texttt{*a.nummer}

ervoor zorgt dat \texttt{a.nummer} een pointer is naar een \texttt{int} (en de variabele a is geen pointer).
Omdat het gebruik van de haakjes zo vaak voorkomt, is er een speciale notatie mogelijk. We kunnen de member operator \texttt{->}\indexop{->} gebruiken om een member van een structure te gebruiken aangewezen door een pointer naar een structure. Dus:

\hspace*{1em}\texttt{a->nummer}

selecteert member \texttt{nummer} van een structure aangewezen door pointer \texttt{a}. De twee volgende voorbeelden zijn daarom equivalent

\hspace*{1em}\texttt{(*a).nummer}\\
\hspace*{1em}\texttt{a->nummer}

Dus om een functie te gebruiken die de gegevens van een nieuwe artikel invult, kunnen de functie \texttt{maak\_artikel} in listing~\ref{cod:struct13} gebruiken.

\booklisting[linerange={20-27},label=cod:struct13,escapeinside={{}{}}]{C}{Een functie om de gegevens van een artikel in te stellen}{struct_artikel_typedef}{c}{H}

Een functie kan ook een pointer naar een structure teruggeven. We kunnen bijvoorbeeld het grootste aantal beschikbare exemplaren van twee artikelen bepalen. Dit is te zien in listing~\ref{cod:struct13a}

\booklisting[linerange={38-40},label=cod:struct13a,escapeinside={{}{}}]{C}{Een functie om grootste aantal artikelen te bepalen}{struct_artikel_typedef}{c}{H}

We hebben hier gebruik gemaakt van de \textsl{conditionele expressie}\index{condtionele expressie}. Deze wordt besproken in paragraaf~\ref{sec:conditioneleexpressie}.

\section{Array van structures}
\index{array!van structures}\index{structure!array van}
Natuurlijk is het niet handig om voor elk artikel een variabele te declareren. We kunnen dan veel beter gebruik maken van een array. De declaratie

\hspace*{1em}\texttt{artikel\_t art[10];}

zorgt ervoor dat we een array van tien artikelen kunnen gebruiken. Om een element uit de array te selecteren gebruiken we de blokhaken \texttt{[]}. Die hebben een lagere prioriteit dan de member operator \texttt{.} (punt) dus er zijn geen haakjes nodig om een member te gebruiken:

\hspace*{1em}\texttt{art[6].aantal += 3;}

zorgt ervoor dat het aantal van \texttt{art[6]} met 3 wordt verhoogd. Bij het meegeven van de array aan een functie moeten we expliciet het aantal arrayelementen opgeven omdat een array altijd via \textsl{Call by Reference}\index{Call by Reference} (dus via een pointer) wordt meegegeven. Zie ook hoofdstuk~\ref{sec:pointersalsfunctieargumenten}.

In listing~\ref{cod:struct14} is een functie te zien die alle gegevens van de artikelen afdrukt. We gaan hier ervan uit dat als een artikel het nummer 0 heeft, dit artikel niet is ingevuld en drukken we de gegevens niet af. 

\booklisting[linerange={29-36},label=cod:struct14,escapeinside={{}{}}]{C}{Een functie om alle gegevens van artikelen af te drukken}{struct_artikel_typedef}{c}{H}

Het aantal elementen kunnen we laten uitrekenen met behulp van de operator \texttt{sizeof}\indexop{sizeof}. We delen de grootte van de totale array door de grootte van één element om het aantal elementen te berekenen.
We roepen de functie aan met

\hspace*{1em}\texttt{print\_artikelen(art, sizeof art / sizeof art[0]);}


\section{Structures binnen structures}
\index{structure!binnen structure}
We kunnen ons programma uitbreiden met bestellingen. We definiëren daartoe drie structures voor artikelen, klanten en bestellingen. De structures zijn te zien in listing~\ref{cod:bestel1}. We merken op dat de structure \texttt{bestelling\_t} naast een uniek bestelnummer ook variabelen hebben van de structure \texttt{klant\_t} en van een array van \texttt{artikel\_t} (we gaan er gemakshalve vanuit dat een bestelling niet meer dan tien verschillende artikelen kan bevatten). We hebben dus structures binnen een structure. Als we een bestelling willen aanmaken dan moeten we naast het bestelnummer ook de klantgegevens en de artikelen opgeven.

\booklisting[linerange={6-23},label=cod:bestel1,escapeinside={{}{}}]{C}{De structures die horen bij een bestelling}{struct_bestelling}{c}{H}

Om een bestelling aan te maken declareren we eerst een variabele van het type \texttt{bestelling\_t} en intialiseren we de structure met nullen. Dat kan door alleen het bestelnummer expliciet met een 0 te initialiseren, de rest wordt automatisch op 0 gezet. Daarna vullen we het bestelnummer in via

\hspace*{1em}\texttt{bestel.bestelnr = 123;}

Om het klantnummer op te geven moeten we via de structure \texttt{klant} in \texttt{bestelling} een waarde opgeven:

\hspace*{1em}\texttt{bestel.klant.klantnr = 73}

We kunnen een artikel bij de bestelling voegen door een artikel in zijn geheel te kopiëren naar een element van de variabele \texttt{artbestel}

\hspace*{1em}\texttt{bestel.artbestel[0] = art[2];}

We moeten dan nog alleen het aantal en de prijs berekenen. Dit is te zien in listing~\ref{cod:bestel2}.

\booklisting[linerange={46-53},label=cod:bestel2,escapeinside={{}{}}]{C}{Een functie om alle gegevens van artikelen af te drukken}{struct_bestelling}{c}{H}

Overigens is het niet slim om alle informatie van een artikel in de structure \texttt{bestel} op te nemen. Als de naam van de klant verandert, dan moeten we in twee structures de naam aanpassen. We kunnen beter alleen het klantnummer opnemen. De gegevens van de klant zijn dan via de klantstructures op te vragen. Zie ook het kader onder aan de bladzijde.

\begin{infobox}[Relationele databases]
Het gebruik van structures is nauw gekoppeld aan \textsl{relationele databases}. We kunnen voor onze winkel bijvoorbeeld \textsl{tabellen} aanmaken met klantgegevens, artikelen en bestellingen. Bij de klantgegevens voeren we de uniek klantnummer, naam, het adres en telefoonnummer in, bij de artikelen een uniek artikelnummer, de naam, het aantal dat beschikbaar is en de prijs per stuk. Als we een bestelling invoeren, hoeven we naast een uniek bestelnummer alleen het nummer van de klant in te voeren; we kunnen de klantgegevens via de klanttabel vinden. Als het adres van de klant verandert, dan hoeven we alleen de klanttabel te veranderen. Natuurlijk moet een lijst met gekochte artikelen worden ingevoerd, maar we hoeven dan alleen het artikelnummer en het aantal in te voeren, de rest is via de artikeltabel te vinden. Het uit elkaar trekken van al die gegevens wordt \textsl{normalisatie} genoemd en zorgt ervoor dat spaarzaam met opslag wordt omgegaan en dat gegevens niet meerdere keren in de database voorkomen (redundantie).
\end{infobox}


\section{Teruggeven van meerdere variabelen}
In C kan een functie slechts één variabele teruggeven. Als we meerdere variabelen willen teruggeven, kunnen we gebruik maken van een structure. De structure ``verpakt'' dan de variabelen onder één noemer.

Een bekend voorbeeld is zijn de oplossingen van een kwadratische vergelijking met de vorm $ax^2+bx+c=0$. We kunnen de \textsl{wortels} (getallen waarvoor de functie 0 oplevert) berekenen met de wortelformule\index{wortelformule}:
%
\begin{equation}
x_{1,2} = \dfrac{-b\pm\sqrt{b^2-4ac}}{2a}
\end{equation}
%
De expressie onder het wortelteken heeft de \textsl{discriminant} en heeft alleen een geldige waar als deze groter is dan of gelijk is aan 0. Verder mag $a$ niet 0 zijn, want dan kunnen we niet delen. We moeten nu in feite drie gegevens bepalen: de wortels $x_1$ en $x_2$ en of de wortels geldig zijn. We pakken deze drie gegevens in in een structure. Het volledige programma is te zien in listing~\ref{cod:wortels1}.

We definiëren een structure met de drie gegevens zoals te zien is in regels 4 t/m 8. In de functie \texttt{bereken\_wortels} berekenen we de wortels als dat mogelijk is en we vullen de status van de wortels in. Kunnen ze niet berekend worden dan zetten we variabele \texttt{geldig} op 0, anders zetten we die variabele op 1. Aan het einde van de functie geven we een nieuw aangemaakte variabele terug. In de functie \texttt{print\_wortels} drukken we de wortels af of dat de wortels niet geldig zijn (kunnen niet berekend worden).

\booklisting[label=cod:wortels1,escapeinside={{}{}}]{C}{Een programma om de wortels van een kwadratische vergelijking te berekenen}{struct_wortels}{c}{H}


\advanced
\section{Unions}
Stel dat we onze eigen C-compiler willen ontwerpen (begin er trouwens niet aan, dat is heel complex). Dan moeten een lijst bijhouden van gedeclareerde variabelen. Van de variabele moet dan ook het type worden opgeslagen en mogelijk een initiële waarde\footnote{Natuurlijk kan de waarde van een variabele tijdens runtime veranderen, maar het zou kunnen dat de compiler erachter komt dat een variabelen op een bepaald moment een bekende waarde heeft. Deze waarde kan dan gebruikt worden bij een expressie.}. We kunnen dan een structure definiëren die alle mogelijke datatypes bevat, maar dat is verkwisten van geheugenruimte; een variabele kan immers maar één datatype hebben. We kunnen dan gebruik maken van een \textsl{union}\indexkeyword{union}.

Binnen een union wordt ruimte gereserveerd voor het grootste datatype (in het aantal bits). In listing~\ref{cod:union1} is een union variabele gedeclareerd met de naam \texttt{value}.

\booklisting[gobble=4,linerange={11-15},label=cod:union1]{C}{Een union om verschillende datatypes te gebruiken}{union}{c}{H}

De gereserveerde geheugenruimte is gelijk aan de grootste variabele, in dit geval een \texttt{double}. We kunnen de union opnemen in een structure met daarin de naam en het type (en natuurlijk de union). Een voorbeeld is te zien in listing~\ref{cod:union2}. We hebben tevens gebruik gemaakt van een \textsl{enumeratie}\index{enumeratie} voor de verschillende datatypes.

\booklisting[linerange={6-16},label=cod:union2,escapeinside={{}{}}]{C}{Een structure om een variabele in een compiler te gebruiken}{union}{c}{H}

We kunnen nu een variabele declareren en initialiseren met gegevens. Dit is te zien in listing~\ref{cod:union3}. Te zien is dat de variabele wordt ingesteld als \texttt{float} en dat de waarde 3,14 bedraagt.

\booklisting[linerange={40-40,43-46},label=cod:union3,escapeinside={{}{}}]{C}{Initialiseren van een variabele}{union}{c}{H}

We kunnen op elk moment het type en de waarde veranderen (dat zou in een C-compiler natuurlijk niet kunnen gebeuren). We kunnen de variabele bijvoorbeeld kenmerken als een integer en er een waarde aan toekennen.

\booklisting[linerange={48-49},label=cod:union4,escapeinside={{}{}}]{C}{Initialiseren van een variabele}{union}{c}{H}

Bij het afdrukken van de waarde van de variabele raadplegen we het type. Met behulp van een \texttt{switch}-statement selecteren we hoe de variabele moet worden afgedrukt.

\booklisting[linerange={18-36},label=cod:union5,escapeinside={{}{}}]{C}{Een functie om een variabele af te drukken}{union}{c}{H}

\basic