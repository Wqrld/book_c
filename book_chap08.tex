\chapter{Structures}
\label{cha:structures}
\thispagestyle{empty}

Een structuur (Engels: structure\footnote{We zullen vanaf nu de Engelse naam structure gebruiken.}) is een verzameling bij elkaar behorende gegevens beschikbaar onder één enkele naam. Dit is vooral handig bij complexe \textsl{datastructuren} want ze helpen om gerelateerde variabelen als een eenheid te bewerken in plaats van een aantal verschillende variabelen. Structures komen overeen met \textsl{rijen} in een relationele database. Een bekend voorbeeld is de loonlijst van werknemers. Een werknemer heeft een naam, een adres, een salaris en een functie.

Een structure kan gezien worden als één enkele variabele. Zo mogen we structures eenvoudig kopiëren met een toekenning, we mogen ze meegeven als argumenten aan een functie, een functie kan een structure in zijn geheel teruggeven, we kunnen het adres van een structure opvragen met de adres-operator \texttt{\&} en we mogen de variabelen binnen de structure gebruiken in expressie. We mogen \textsl{niet} twee structures vergelijken.

\section{Definitie van structures en variabelen}
Een welhaast klassiek voorbeeld van een structure is een aantal artikelen. Van de artikelen geven we het artikelnummer, de naam, het aantal dat beschikbaar is en de prijs per stuk op. We definiëren de structure \texttt{artikel} als volgt:

% We gebruiken label=cod:struct1 om de standaard label te wijzigen
\booklistingfromproject[linerange={6-11},label=cod:struct1]{C}{De structure \texttt{artikel}}{struct_artikel}{c}{H}

De variabelen binnen de structure worden \textsl{leden} genoemd maar we zullen gebruik maken van de Engelse naam \textsl{members}\index{member}\index{structure!member}\indexkeyword{struct}.

We kunnen nu de structure gebruiken in definities door gebruik te maken van

\hspace*{1em}\texttt{struct artikel} \textsl{variabele}\texttt{;}

om variabelen te definiëren. In listing~\ref{cod:struct2} is een aantal definities te zien:

\booklistingfromproject[linerange={40-43},label=cod:struct2]{C}{Definitie van enkele variabelen}{struct_artikel}{c}{H}

In regel 1 wordt de variabele \texttt{floppy} gedefinieerd zonder initialisatie. We kunnen bij definitie gelijk de members initialiseren zoals te zien is in regels 3 en 4. In de initialisatielijst moeten natuurlijk wel de juiste datatypes gebruikt worden, tenzij automatische conversie mogelijk is. Structures mogen zowel globaal als lokaal worden gedefinieerd.

\section{Toegang tot members}
Om gebruik te maken van een member gebruiken we de \textsl{member operator} \texttt{.}\indexop{.} (punt). Om de prijs van het artikel \texttt{floppy} in te stellen kunnen we bijvoorbeeld gebruiken:

\hspace*{1em}\texttt{floppy.prijs = 10.73;}

Om het aantal af te drukken gebruiken we \texttt{printf} met de member \texttt{aantal}:

\hspace*{1em}\texttt{printf("Aantal beschikbaar is \%d", floppy.aantal);}

Om het aantal beschikbare exemplaren van een artikel te verhogen kunnen we de member \texttt{aantal} verhogen:

\hspace*{1em}\texttt{floppy.aantal += 5; \ \ // 5 exemplaren erbij}

Let erop dat de naam van een artikel een \textsl{string} is. Om de naam aan te passen moeten we gebruik maken van de functie \texttt{strcpy}\indexfunc{strcpy}:

\hspace*{1em}\texttt{strcpy(floppy.naam, "Floppy 3.5 in");}

\section{Functies met structures}
Stel dat we de gegevens van een artikel willen afdrukken. Dan kunnen we natuurlijk alle members apart afdrukken. Maar is het handiger om een functie te definiëren die dat voor ons doet. Een structure mag gewoon als argument aan een functie worden weergegeven\index{structure!als argument} of dienen als parameter in een functie\index{structure!als parameter}. In de functie kunnen we dan de members een voor een afdrukken. Dit is te zien in listing~\ref{cod:struct3}. We hebben extra spaties toegevoegd om de gegevens van elkaar te scheiden.

\booklistingfromproject[linerange={13-18},label=cod:struct3]{C}{Afdrukken van de gegevens van een  artikel}{struct_artikel}{c}{H}

Als we een nieuw artikel willen toevoegen, kunnen we alle members van de structure een waarde toekennen. Maar het is gemakkelijker om een functie te definiëren die dat voor ons doet. Een mogelijke functie is te zien in listing~\ref{cod:struct4}.

\booklistingfromproject[linerange={20-30},label=cod:struct4]{C}{Aanmaken van een nieuw artikel}{struct_artikel}{c}{H}

De parameters krijgen de waarden mee die aan de members moeten worden toegekend. Om een nieuwe structure te maken waar de gegevens inkomen, definiëren we in regel 3 een structure met de naam \texttt{nieuw}. We moeten daarna een voor een de waarden aan de members toekennen. Vervolgens geven we de gehele structure terug aan de aanroeper.

We kunnen de structure \texttt{floppy} bijvoorbeeld initialiseren met:

\hspace*{1em}\texttt{floppy = maak\_artikel(7, "Floppy", 5, 10.73);}

\section{Typedef}
\index{structure!typedef}
Met behulp van het keyword \texttt{typedef}\indexkeyword{typedef} kunnen we een structure beschikbaar stellen onder een eigen datatype. Zo kunnen we het nieuwe type \texttt{artikel\_t} aanmaken met de definitie in listing~\ref{cod:struct11}. Let erop dat \texttt{artikel\_t} geen echt nieuw datatype is, het is meer een synoniem. Het blijft onder alle omstandigheden een structure. We mogen dan ook de naam na \texttt{struct} achterwege laten. Merk op dat de definitie van de oorspronkelijke structure tussen \texttt{typedef} en \texttt{artikel\_t} staat.

\booklistingfromproject[linerange={6-11},label=cod:struct11]{C}{De definitie van datatype \texttt{artikel\_t}}{struct_artikel_typedef}{c}{H}

Vervolgens kunnen we variabelen definiëren met de \texttt{typedef}:

\hspace*{1em}\texttt{artikel\_t floppy, sdcard, usbstick;}

We kunnen \texttt{typedef} ook gebruiken bij andere datatypes:

\hspace*{1em}\texttt{typedef unsigned long int ulint;}

\texttt{Typedef}'s zijn handig om een programma onafhankelijke te maken van de C-compiler die gebruikt wordt en de computer waarop het programma draait. Als een programma verplaatst wordt naar een andere computer (dat wordt \textsl{porteren} genoemd), hoeven alleen de \texttt{typedef}'s te worden aangepast. Daarna kan het programma gecompileerd worden met de nieuwe \texttt{typedef}'s.

\section{Pointers naar structures}
\index{structure!pointer naar}\index{pointer!naar structure}
Als een structure een groot aantal members bevat, is het niet handig om een hele structure aan een functie mee te geven als parameter. Een argument dat wordt meegegeven wordt namelijk gekopieerd naar de parameters. Het is dan beter om een pointer naar een structure mee te geven. Bijkomend voordeel (of is het een probleem?) is dat ook gelijk de members van de structure kunnen worden aangepast. Als we willen dat een argument niet kan worden aangepast, gebruiken we het keyword \texttt{const}\indexkeyword{const} bij de parameterdefinitie. De compiler ziet er dan op toe dat in de functie geen members worden aangepast en als dat toch gebeurt, volgt een foutmelding. Zie listing~\ref{cod:struct12} voor de functie voor het afdrukken van gegevens van een artikel.

\booklistingfromproject[linerange={13-18},label=cod:struct12,escapeinside={{}{}}]{C}{Een functie om de gegevens van een artikel af te drukken}{struct_artikel_typedef}{c}{H}

In regel 1 wordt een pointer naar een structure \texttt{artikel\_t} gedefinieerd. Let op het keyword \texttt{const} dat aangeeft dat in de functie de members niet worden aangepast. In regel 2 is te zien hoe het artikelnummer wordt afgedrukt. Let hierbij op de haakjes om de pointervariabele. Die zijn nodig omdat de member operator \texttt{.} (punt) een hogere prioriteit heeft dan de dereferentie-operator \texttt{*}. Dus:

\hspace*{1em}\texttt{(*a).nummer}

selecteert member \texttt{nummer} van de structure die aangewezen wordt door pointer \texttt{a} terwijl

\hspace*{1em}\texttt{*a.nummer}

ervan uitgaat dat \texttt{a.nummer} een pointer is naar een \texttt{int} (en de variabele a is geen pointer).
Omdat het gebruik van de haakjes niet zo duidelijk overkomt, is er een andere notatie mogelijk. We kunnen de member operator \texttt{->}\indexop{->} gebruiken om een member van een structure te gebruiken aangewezen door een pointer naar een structure. Dus:

\hspace*{1em}\texttt{a->nummer}

selecteert member \texttt{nummer} van een structure aangewezen door pointer \texttt{a}. De twee volgende voorbeelden zijn daarom equivalent

\hspace*{1em}\texttt{(*a).nummer}\\
\hspace*{1em}\texttt{a->nummer}

Dus om een functie te gebruiken die de gegevens van een nieuwe artikel invult, kunnen we de functie \texttt{vul\_artikel} in listing~\ref{cod:struct13} gebruiken.

\booklistingfromproject[linerange={20-27},label=cod:struct13,escapeinside={{}{}}]{C}{Een functie om de gegevens van een artikel in te stellen}{struct_artikel_typedef}{c}{H}

Een functie kan ook een pointer naar een structure teruggeven. We kunnen bijvoorbeeld het grootste aantal beschikbare exemplaren van twee artikelen bepalen. Dit is te zien in listing~\ref{cod:struct13a}

\booklistingfromproject[linerange={38-40},label=cod:struct13a,escapeinside={{}{}}]{C}{Een functie om grootste aantal artikelen te bepalen}{struct_artikel_typedef}{c}{H}

We hebben hier gebruik gemaakt van de \textsl{conditionele expressie}\index{condtionele expressie}. Deze wordt behandeld in paragraaf~\ref{sec:conditioneleexpressie}.

\section{Array van structures}
\index{array!van structures}\index{structure!array van}
Natuurlijk is het niet handig om voor elk artikel een variabele te definiëren. We kunnen dan veel beter gebruik maken van een array. De definitie

\hspace*{1em}\texttt{artikel\_t art[10];}

zorgt ervoor dat we een array van tien artikelen kunnen gebruiken. Om een element uit de array te selecteren gebruiken we de blokhaken \texttt{[]}. Die hebben een lagere prioriteit dan de member operator \texttt{.} (punt) dus er zijn geen haakjes nodig om een member te gebruiken:

\hspace*{1em}\texttt{art[6].aantal += 3;}

zorgt ervoor dat \texttt{aantal} van \texttt{art[6]} met 3 wordt verhoogd. Bij het meegeven van de array aan een functie moeten we expliciet het aantal arrayelementen opgeven omdat een array middels een pointer naar het eerste element wordt meegegeven. Zie ook hoofdstuk~\ref{sec:pointersalsfunctieargumenten}.

In listing~\ref{cod:struct14} is een functie te zien die alle gegevens van de artikelen afdrukt. We gaan hier ervan uit dat als een artikel het nummer 0 heeft, dit artikel niet is ingevuld en drukken we de gegevens niet af. 

\booklistingfromproject[linerange={29-36},label=cod:struct14,escapeinside={{}{}}]{C}{Een functie om alle gegevens van artikelen af te drukken}{struct_artikel_typedef}{c}{H}

Het aantal elementen kunnen we laten uitrekenen met behulp van de operator \texttt{sizeof}\indexop{sizeof}. We delen de grootte van de totale array door de grootte van één element om het aantal elementen te berekenen.
We roepen de functie aan met

\hspace*{1em}\texttt{print\_artikelen(art, sizeof art / sizeof art[0]);}


\section{Structures binnen structures}
\index{structure!binnen structure}
We kunnen ons programma uitbreiden met bestellingen. We definiëren daartoe drie structures voor artikelen, klanten en bestellingen. De structures zijn te zien in listing~\ref{cod:bestel1}. We merken op dat de structure \texttt{bestelling\_t} naast een uniek bestelnummer ook variabelen hebben van de structure \texttt{klant\_t} en van een array van \texttt{artikel\_t} (we gaan er gemakshalve vanuit dat een bestelling niet meer dan tien verschillende artikelen kan bevatten). We hebben dus structures binnen een structure. Als we een bestelling willen aanmaken dan moeten we naast het bestelnummer ook de klantgegevens en de artikelen opgeven.

\booklistingfromproject[linerange={6-23},label=cod:bestel1,escapeinside={{}{}}]{C}{De structures die horen bij een bestelling}{struct_bestelling}{c}{H}

Om een bestelling aan te maken definiëren we eerst een variabele van het nieuwe datatype \texttt{bestelling\_t} en initialiseren we de structure met nullen. Dit is te zien in listing~\ref{cod:bestel2}. Dat kan door alleen het bestelnummer expliciet met een 0 te initialiseren, de andere members wordt automatisch op 0 gezet. Daarna vullen we het bestelnummer in via

\hspace*{1em}\texttt{bestel.bestelnr = 123;}

Om het klantnummer op te geven moeten we via de structure \texttt{klant} in \texttt{bestelling} een waarde opgeven:

\hspace*{1em}\texttt{bestel.klant.klantnr = 73}

We kunnen een artikel bij de bestelling voegen door een artikel in zijn geheel te kopiëren naar een element van de variabele \texttt{artbestel}

\hspace*{1em}\texttt{bestel.artbestel[0] = art[2];}

We moeten dan alleen nog het aantal en de prijs berekenen. Dit is te zien in listing~\ref{cod:bestel2}.

\booklistingfromproject[linerange={46-53},label=cod:bestel2,escapeinside={{}{}}]{C}{Een functie om alle gegevens van artikelen af te drukken}{struct_bestelling}{c}{H}

Overigens is het niet slim om alle informatie van een artikel in de structure \texttt{bestel} op te nemen. Als de naam van de klant verandert, dan moeten we in twee structures de naam aanpassen. We kunnen beter alleen het klantnummer opnemen. De gegevens van de klant zijn dan via de klantstructures op te vragen. Zie ook het kader onder aan de pagina.

\begin{infobox}[Relationele databases]
Het gebruik van structures is nauw gekoppeld aan \textsl{relationele databases}. We kunnen voor onze winkel bijvoorbeeld \textsl{tabellen} aanmaken met klantgegevens, artikelen en bestellingen. Bij de klantgegevens voeren we de uniek klantnummer, naam, het adres en telefoonnummer in, bij de artikelen een uniek artikelnummer, de naam, het aantal dat beschikbaar is en de prijs per stuk. Als we een bestelling invoeren, hoeven we naast een uniek bestelnummer alleen het nummer van de klant in te voeren; we kunnen de klantgegevens via de klanttabel vinden. Als het adres van de klant verandert, dan hoeven we alleen de klanttabel te veranderen. Natuurlijk moet een lijst met gekochte artikelen worden ingevoerd, maar we hoeven dan alleen het artikelnummer en het aantal in te voeren, de rest is via de artikeltabel te vinden. Het uit elkaar trekken van al die gegevens wordt \textsl{normalisatie} genoemd en zorgt ervoor dat spaarzaam met opslag wordt omgegaan en dat gegevens niet meerdere keren in de database voorkomen (redundantie).
\end{infobox}


\section{Teruggeven van meerdere variabelen}
In C kan een functie slechts één variabele teruggeven. Als we meerdere variabelen willen teruggeven, kunnen we gebruik maken van een structure. De structure `verpakt' dan de variabelen onder één noemer.

Een bekend voorbeeld is het berekenen van de oplossingen van een kwadratische vergelijking met de vorm $ax^2+bx+c=0$. We kunnen de \textsl{wortels} (getallen waarvoor de functie~0 oplevert) berekenen met de wortelformule\index{wortelformule}:
%
\begin{equation}
x_{1,2} = \dfrac{-b\pm\sqrt{b^2-4ac}}{2a}
\end{equation}
%
De expressie onder het wortelteken heet de \textsl{discriminant} en de wortel van de discriminant heeft alleen een reële waarde als deze groter is dan of gelijk is aan 0. Verder mag $a$ niet~0 zijn, want dan kunnen we niet delen. We moeten nu in feite drie gegevens bepalen: de wortels $x_1$ en $x_2$ en of de wortels geldig zijn. We pakken deze drie gegevens in in een structure. Het volledige programma is te zien in listing~\ref{cod:struct_wortels}.

We definiëren een structure met de drie gegevens zoals te zien is in regels 4 t/m 8. In de functie \texttt{bereken\_wortels} berekenen we de wortels als dat mogelijk is en we vullen de status van de wortels in. Kunnen ze niet berekend worden dan zetten we variabele \texttt{geldig} op 0, anders zetten we die variabele op 1. Aan het einde van de functie geven we een nieuw aangemaakte variabele terug. In de functie \texttt{print\_wortels} drukken we de wortels af of dat de wortels niet geldig zijn (kunnen niet berekend worden).

\booklistingfromproject[escapeinside={{}{}}]{C}{Een programma om de wortels van een kwadratische vergelijking te berekenen}{struct_wortels}{c}{H}

Merk overigens op dat als de discriminant 0 is, de wortels $x_1$ en $x_2$ dezelfde waarde hebben.

\advanced
\section{Unions}
Stel dat we onze eigen C-compiler willen ontwerpen (begin er trouwens niet aan, dat is heel complex). Dan moeten we een lijst bijhouden van gedefinieerde variabelen. Van de variabele moet dan ook het type worden opgeslagen en mogelijk een initiële waarde\footnote{Natuurlijk kan de waarde van een variabele tijdens runtime veranderen, maar het zou kunnen dat de compiler erachter komt dat een variabele op een bepaald moment een bekende waarde heeft. Deze waarde kan dan gebruikt worden bij een expressie of initialisatie.}. We kunnen dan een structure definiëren die alle mogelijke datatypes bevat, maar dat is verkwisten van geheugenruimte; een variabele kan immers maar één datatype hebben. We kunnen dan gebruik maken van een \textsl{union}\indexkeyword{union}.

Binnen een union wordt ruimte gereserveerd voor het grootste datatype (in het aantal bits). In listing~\ref{cod:union1} is een union variabele gedefinieerd met de naam \texttt{value}.

\booklistingfromproject[gobble=4,linerange={11-15},label=cod:union1]{C}{Een union om verschillende datatypes te gebruiken}{union}{c}{H}

De gereserveerde geheugenruimte is gelijk aan de geheugenruimte van de grootste variabele, in dit geval een \texttt{double}. We kunnen de union opnemen in een structure met daarin de naam en het type (en natuurlijk de union). Een voorbeeld is te zien in listing~\ref{cod:union2}. We hebben tevens gebruik gemaakt van een \textsl{enumeratie}\index{enumeratie} (zie paragraaf~\ref{sec:enumeraties}) voor de verschillende datatypes.

\booklistingfromproject[linerange={6-16},label=cod:union2,escapeinside={{}{}}]{C}{Een structure om een variabele in een compiler te gebruiken}{union}{c}{H}

We kunnen nu een variabele definiëren en initialiseren met gegevens. Dit is te zien in listing~\ref{cod:union3}. Te zien is dat de variabele wordt ingesteld als \texttt{float} en dat de waarde 3,14 bedraagt.

\booklistingfromproject[linerange={40-40,43-46},label=cod:union3,escapeinside={{}{}}]{C}{Initialiseren van een variabele}{union}{c}{H}

We kunnen op elk moment het type en de waarde veranderen (dat zou in een C-compiler natuurlijk niet kunnen gebeuren). We kunnen de variabele bijvoorbeeld kenmerken als een integer en er een waarde aan toekennen.

\booklistingfromproject[linerange={48-49},label=cod:union4,escapeinside={{}{}}]{C}{Initialiseren van een variabele}{union}{c}{H}

Bij het afdrukken van de waarde van de variabele raadplegen we het type. Met behulp van een \texttt{switch}-statement selecteren we hoe de variabele moet worden afgedrukt.

\booklistingfromproject[linerange={18-36},label=cod:union5,escapeinside={{}{}}]{C}{Een functie om een variabele af te drukken}{union}{c}{H}

\section{Bitvelden}
Bitvelden maken het mogelijk om delen van een geheugenplaats (of meerdere geheugenplaatsen gegroepeerd als één geheel), onder te verdelen in afzonderlijke bits. Dit is vooral handig bij het aansturen van hardware.

Stel dat we een (fictieve) hardwarematige \textsl{teller} (Engels: counter) willen aansturen. De gegevens van de teller worden met 32 bits weergegeven. In listing~\ref{cod:bitfields} is de indeling van de~32 bits te zien. De tellerwaarde bestaat uit 16 bits, dus de teller kan tellen van 0 t/m 65535. Dit wordt weergegeven met het veld \texttt{value}. De teller telt \textsl{cyclisch} dus na de hoogste waarde volgt weer de laagste waarde. De teller heeft dan een \textsl{overflow} gehad. Dit wordt weergegeven met het veld \texttt{overflow}. De teller heeft acht mogelijke manieren van tellen (omhoog, omlaag etc.). Dit wordt weergegeven met het veld \texttt{mode}. Als een speciale \textsl{interruptfunctie} gestart moet worden, geven we dat aan met het veld \texttt{interrupt\_enable}.

\begin{lstlisting}[caption=Voorbeeld van bitvelden.,label=cod:bitfields]
struct {
    unsigned int interrupt_enable : 1; /* Bit 31 */
    unsigned int padding : 0;          /* Bits 30 down to 21 */
    unsigned int mode : 3;             /* Bits 20 down to 18 */
    unsigned int enable : 1;           /* Bit 17 */
    unsigned int overflow : 1;         /* Bit 16 */
    unsigned int value : 16;           /* Bits 15 down to 0 */
} counter;

\end{lstlisting}

Het veld \texttt{padding} heeft de speciale breedte 0 om ervoor te zorgen dat de velden worden \textsl{opgelijnd} naar de breedte die van nature door de computer worden verwerkt. Een veel gebruikte term hiervoor is \textsl{machinewoord}. De bit \texttt{interrupt\_enable} komt daardoor op positie 31 terecht, de andere bits lopen van 0 t/m 20.


Om te teller te starten gebruiken we:

\hspace*{1em}\texttt{counter.enable = 1;}

Om de tellerwaarde te kopiëren naar een variabele gebruiken we:

\hspace*{1em}\texttt{unsigned int value = counter.value;}

Om te testen of een overflow heeft plaatsgevonden, gebruiken we:

\hspace*{1em}\texttt{if (counter.overflow == 1) \{ ... \} }

Alles aan het gebruik van bitvelden is afhankelijk van de hardware waarop het programma draait en de C-compiler die gebruikt wordt. Dat betekent dat programma's met bitvelden moeilijk overdraagbaar zijn naar andere computers en andere C-compilers. Bij systemen die van nature met 32 bits werken worden de bits (hoogst waarschijnlijk) samengepakt in 32 bits eenheden.

Bitvelden werden vroeger gebruikt om geheugenruimte te besparen. Tegenwoordig is dat niet meer nodig omdat de meeste computers genoeg geheugen hebben. Het gebruik van bitvelden wordt daarom ook afgeraden.


\section{Gekoppelde lijsten}
We kunnen structures en pointers gebruiken voor het ontwikkelen van \textsl{gekoppelde lijsten}\index{gekoppelde lijsten}. We zullen in het vervolg echter gebruik maken van de Engelse term \textsl{linked lists}\index{linked lists}. De basis van een linked list wordt gevormd door een structure met daarin een pointer member die kan wijzen naar een andere structure van hetzelfde type. Zo'n structure wordt doorgaans een \textsl{node}\index{node} genoemd. Laten we eens een lijst maken met leeftijden en namen. We definiëren een node met daarin de member \lstc{age} voor de leeftijd en een member \lstc{name} voor de naam. Daarnaast definiëren we een \textsl{pointer} naar zo'n zelfde node met de naam \lstc{next}. De definitie van de node is hieronder te zien.

\begin{lstlisting}[style=lstoneline]
struct node {
	int age;
	char name[20];
	struct list *next;
};
\end{lstlisting}

Naast de twee eerder opgegeven members is nu ook een member \lstc{next} te zien die een pointer is naar zo'n zelfde node. In het boek van K\&R wordt dit ook wel een \textsl{self-referential structure}\index{self-referential structure} genoemd. Het is met deze node mogelijk om te wijzen naar een \textsl{andere} node van hetzelfde type (maar in principe ook naar zichzelf).

We kunnen nu een node van dit type initialiseren:

\begin{lstlisting}[style=lstoneline]
struct node a = { 43, "Inge", NULL };
\end{lstlisting}

De member \lstc{next} wordt geïnitialiseerd met NULL, dat betekent dat \lstc{next} naar niets wijst. Een uitbeelding van de node is te zien in figuur~\ref{fig:strstr1}. Het kruis geeft aan dat de member \lstc{next} naar niets wijst.

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[line width=1pt, font=\small\ttfamily, start chain]
\node[list,on chain] (A) {43 \nodepart{two} \strut Inge}; 
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (A.north east) -- (A.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (A.south east) -- (A.two split north);
\end{tikzpicture}
\caption{Uitbeelding van de node.}
\label{fig:strstr1}
\end{figure}

We kunnen meerdere variabelen (nodes) aanmaken, zie hieronder:

\begin{lstlisting}[style=lstoneline]
struct node a = { 43, "Inge", NULL };
struct node b = { 18, "Jesscia", NULL };
struct node c = { 37, "Karin", NULL };
struct node d = { 14, "Janet", NULL };
\end{lstlisting}

We kunnen dit voorstellen met de afbeelding in figuur~\ref{fig:strstr2}.

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[line width=1pt, font=\small\ttfamily, start chain]
\node[list,on chain] (A) {43 \nodepart{two} Inge}; 
\node[list,on chain] (B) {18 \nodepart{two} Jessica};
\node[list,on chain] (C) {37 \nodepart{two} Karin};
\node[list,on chain] (D) {14 \nodepart{two} Janet};
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (A.north east) -- (A.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (A.south east) -- (A.two split north);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (B.north east) -- (B.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (B.south east) -- (B.two split north);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (C.north east) -- (C.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (C.south east) -- (C.two split north);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (D.north east) -- (D.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (D.south east) -- (D.two split north);
\end{tikzpicture}
\caption{Uitbeelding van de vier nodes.}
\label{fig:strstr2}
\end{figure}

Door middel van het statement

\begin{lstlisting}[style=lstoneline]
a.next = &b;
\end{lstlisting}

kunnen we de member \lstc{next} (de pointer) laten wijzen naar node \lstc{b}. De uitbeelding van dit statement is te zien in figuur~\ref{fig:strstr3}.

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[line width=1pt, font=\small\ttfamily, start chain]
\node[list,on chain] (A) {43 \nodepart{two} Inge}; 
\node[list,on chain] (B) {18 \nodepart{two} Jessica};
\node[list,on chain] (C) {37 \nodepart{two} Karin};
\node[list,on chain] (D) {14 \nodepart{two} Janet};
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (B.north east) -- (B.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (B.south east) -- (B.two split north);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (C.north east) -- (C.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (C.south east) -- (C.two split north);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (D.north east) -- (D.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (D.south east) -- (D.two split north);
\draw[dotarrow] (A.three |- A.center) -- (B);
\end{tikzpicture}
\caption{Uitbeelding van de vier nodes, \lstc{a} wijst naar \lstc{b}.}
\label{fig:strstr3}
\end{figure}

Natuurlijk kunnen we op dezelfde wijze de andere nodes ook naar de volgende in de linked list laten wijzen. Dit is te zien in de onderstaande listing. De uitbeelding is te zien in figuur~\ref{fig:strstr4}.

\begin{lstlisting}[style=lstoneline]
a.next = &b;
b.next = &c;
c.next = &d;
\end{lstlisting}

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[line width=1pt, font=\small\ttfamily, start chain]
\node[list,on chain] (A) {43 \nodepart{two} Inge}; 
\node[list,on chain] (B) {18 \nodepart{two} Jessica};
\node[list,on chain] (C) {37 \nodepart{two} Karin};
\node[list,on chain] (D) {14 \nodepart{two} Janet};
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (D.north east) -- (D.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (D.south east) -- (D.two split north);
\draw[dotarrow] (A.three |- A.center) -- (B);
\draw[dotarrow] (B.three |- B.center) -- (C);
\draw[dotarrow] (C.three |- C.center) -- (D);
\end{tikzpicture}
\caption{Uitbeelding van de vier nodes, \lstc{a} wijst naar \lstc{b}, \lstc{b} wijst naar \lstc{c} en \lstc{c} wijst naar \lstc{d}.}
\label{fig:strstr4}
\end{figure}

We hebben nu een \textsl{linked list} gemaakt waarbij we van een node naar een andere node kunnen ``springen''.

Laten we de linked list nu eens afdrukken. Daarvoor hebben we een pointer variabele nodig die we \lstc{current} noemen. Natuurlijk moet \lstc{current} in het begin wijzen naar het adres van \lstc{a}. We definiëren én initialiseren deze variabele als

\begin{lstlisting}[style=lstoneline]
struct node *current = &a;
\end{lstlisting}

Nu kunnen we de leeftijd en naam in \lstc{a} ook afdrukken met

\begin{lstlisting}[style=lstoneline]
current->age (* \textrm{en} *) current->name
\end{lstlisting}

Om naar de volgende node te wijzen (node \lstc{b}) gebruiken we het statement

\begin{lstlisting}[style=lstoneline]
current = current->next;
\end{lstlisting}

Maar dat mag natuurlijk alleen als \lstc{current} ongelijk aan \lstc{NULL} is want dan is er geen volgende in de lijst. Om de hele linked list nu af te drukken gebruiken we een \lstc{while}-statement. Dit is te zien in de onderstaande listing.

\begin{lstlisting}[style=lstoneline]
/* While we're not at the end of the list */
while (current != NULL) {
    /* Print the data */
	printf("Age: %2d, name: %s\n", current->age, current->name);
    /* Point to the next in the list */
	current = current->next;
}
\end{lstlisting}

Met dit \lstc{while}-statement lopen we van het begin tot aan het einde van de linked list. Dit wordt in het Engels \textsl{traversal} (to traverse: langslopen) genoemd. In figuur~\ref{fig:strstrtranversal} is de traversal van de pointer \lstc{current} te zien. Pointer \lstc{current} begint bij node \lstc{a}, gaat daarna naar \lstc{b} en daarna naar \lstc{c} en eindigt vervolgens bij \lstc{d}. Dat is het einde van de linked list, want \lstc{d} heeft geen opvolger, en dus stopt de \lstc{while}-lus.
Het complete programma is te zien in listing~\ref{cod:linked_list_simple}.

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[line width=1pt, font=\small\ttfamily, start chain]
% The nodes on the chain except for tail
\node[on chain] (dummy) {};
\node[list,on chain] (A) {43 \nodepart{two} Inge}; 
\node[list,on chain] (B) {18 \nodepart{two} Jessica};
\node[list,on chain] (C) {37 \nodepart{two} Karin};
\node[list,on chain] (D) {14 \nodepart{two} Janet};
\node[headtail,below=of dummy,yshift=-0.5cm] (current) {\phantom{current}};

% The null-pointer cross
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (D.north east) -- (D.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt]  (D.south east) -- (D.two split north);

% The connecting arrows
\draw[dotarrow] (A.three |- A.center) -- (B);
\draw[dotarrow] (B.three |- B.center) -- (C);
\draw[dotarrow] (C.three |- C.center) -- (D);
\draw[fill=black] (current.center) circle (0.08);
\draw[-latex] (current.center) to[bend right] (A.one south);
\draw[dashed] (current.center) -- (current.center -| A.three);
\draw[-latex,dashed,out=0] (current.center -| A.three) to[bend right] (B.one south);
\draw[dashed] (current.center -| A.three) -- (current.center -| B.three);
\draw[-latex,dashed,out=0] (current.center -| B.three) to[bend right] (C.one south);
\draw[dashed] (current.center -| B.three) -- (current.center -| C.three);
\draw[-latex,dashed] (current.center -| C.three) to[bend right] (D.one south);

\node[yshift=\unitsize cm] at (current.center) {current};   
\end{tikzpicture}
\caption{Traversal van de pointer \lstc{current}.}
\label{fig:strstrtranversal}
\end{figure}

\booklistingfromproject[lineskip=-1.1pt]{C}{Aanmaken van enkele nodes en de traversal van de nodes}{linked_list_simple}{c}{H}

% Needed to trigger latex to create a new page */
\subsection{Dynamisch gekoppelde lijsten}
Nu biedt het opzetten van een linked list op deze manier niet veel meerwaarde. We hadden de nodes ook in een array kunnen plaatsen. Het aantal nodes staat namelijk vast.

Het wordt echter interessant wanneer we van te voren niet weten hoeveel nodes er gebruikt gaan worden. Met \textsl{dynamische geheugenallocatie} (zie paragraaf~\ref{sec:dynamischegeheugenallocatie}) is het mogelijk om tijdens de executie van een programma nieuwe nodes aan te maken en in de linked list op te nemen.

We gaan nu een programma ontwerpen dat de leeftijd en naam van personen inleest en deze gegevens in een linked list plaatst. Daarbij onderscheiden we de volgende functionaliteiten:

\begin{itemize}
\item Inlezen van leeftijd en naam;
\item Aanmaken van een nieuwe node en vullen met de gegevens. Tevens wordt de nieuwe node opgenomen aan het einde van de linked list;
\item Afdrukken van de complete linked list;
\item Verwijderen van de complete linked list.
\end{itemize}

Voor het aanmaken van een nieuwe node ontwerpen we de functie \lstc{create_node}, het afdrukken van de linked list doen we met de functie \lstc{print_all_nodes} en voor het verwijderen van de linked list gebruiken we de functie \lstc{remove_all_nodes}. Het inlezen van de gegevens en het aanmaken van een nieuwe node gebeurt in een \lstc{do while}-lus. Als we klaar zijn met inlezen, drukken we de linked list af en verwijderen we de linked list.

Omdat we enkele functies uit de standard library gebruiken, laden we eerst de benodigde header-bestanden. Dit is te zien in het onderstaande programmafragment.

\booklistingfromproject[linerange={1-4},style=lstoneline,label=dummy10]{C}{}{linked_list_malloc}{c}{!ht}

De node die we gebruiken is hieronder gedefinieerd.

\booklistingfromproject[linerange={9-14},style=lstoneline,label=dummy20]{C}{}{linked_list_malloc}{c}{!ht}

De linked list wordt dynamisch opgebouwd en om het begin van de linked list aan te geven, moeten we bijhouden waar het begin is. Dit wordt doorgaans de \textsl{head} van de linked list genoemd. We gebruiken hiervoor een pointer \lstc{head}. Deze pointer wijst dus altijd naar het begin van de linked list. In eerste instantie wijst de pointer naar niets, vandaar de initialisatie met \lstc{NULL}. Merk op dat \lstc{head} globaal gedefinieerd is zodat de functies de pointer kunnen gebruiken.

\booklistingfromproject[linerange={16-17},style=lstoneline,label=dummy22]{C}{}{linked_list_malloc}{c}{!ht}

Omdat we drie functies gebruiken, declareren we de prototypes. Dit is te zien in onderstaande programmafragment.

\booklistingfromproject[linerange={19-24},style=lstoneline,label=dummy30]{C}{}{linked_list_malloc}{c}{!ht}

Laten we nu eens kijken naar de opzet van het programma. We bekijken eerst de functie \lstc{main}. Dit is te zien in listing~\ref{cod:linked_list_malloc}.
%
\booklistingfromproject[linerange={26-54}]{C}{De body van het programma}{linked_list_malloc}{c}{!b}
%
Het inlezen van de gegevens wordt gedaan met behulp van een \lstc{do while}-lus die loopt van regel 8 t/m 20. Het stopcriterium is een leeftijd kleiner dan of gelijk aan 0. Het inlezen wordt gedaan in de regels 8 t/m 12 middels de bekende \lstc{scanf}-functie. In regel 14 wordt de functie \lstc{create_node} aangeroepen met de leeftijd en naam als argumenten. Als het aanmaken \textsl{niet} lukt, dan wordt het programma met een foutmelding verlaten. Nadat de lus is verlaten, wordt de linked list afgedrukt met de functie \lstc{print_all_nodes}. Als laatste wordt de linked list verwijderd met \lstc{remove_all_nodes}.

De functie \lstc{create_node} is te zien in listing~\ref{cod:strcreatenode}. De functie moet drie zaken afhandelen: dynamisch alloceren van geheugen om een nieuwe node aan te maken, het plaatsen van de node aan het einde van de linked list en het vullen van de gegevens in de nieuwe structure.

\booklistingfromproject[linerange={55-91},label=cod:strcreatenode]{C}{De functie \lstc{create_node}}{linked_list_malloc}{c}{!ht}

In regel 7 wordt via de functie \lstc{malloc} een stuk geheugen gealloceerd. De grootte wordt bepaald met behulp van de operator \lstc{sizeof} zodat er precies genoeg geheugen wordt opgevraagd om de node te plaatsen. In regels 10 t/m 12 wordt getest of het alloceren gelukt is. Dat kan mislukken als er al teveel geheugen is opgevraagd. Dan geven we als returnwaarde \lstc{NULL} terug ten teken van het mislukken van de allocatie.

Als het alloceren van het geheugen gelukt is, bevat de pointer \lstc{created} het adres van de node. We moeten nu alleen nog bepalen of dit de eerste node in de linked list is. Zo ja, dan moet \lstc{head} gaan wijzen naar de nieuwe node. Dit wordt gerealiseerd in regels 16 t/m 18. Als er al één of meerdere nodes zijn aangemaakt, dan moeten we het einde van de linked list zien te vinden. Dit wordt gerealiseerd in regels 20 t/m 28.

Om goed te begrijpen hoe het vinden van het einde van de linked list werkt, hebben we een uitbeelding gemaakt van vier nodes. Dit is te zien in figuur~\ref{fig:strstrfindingendoflist}. Hierbij hebben we de nodes de namen $A$, $B$, $C$ en $D$ gegeven. Node $A$ ligt aan het begin van de linked list en node $D$ ligt aan het einde van de linked list. In de figuur is te zien dat \lstc{head} wijst naar node $A$, de eerste in de linked list. De pointer \lstc{current} gebruiken we om langs de linked list te lopen. Uiteindelijk wordt het einde van de linked list gevonden. Dit is aangegeven met de (pseudo)-pointer \lstc{current@end}.

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[line width=1pt, font=\small\ttfamily, start chain]
% The nodes on the chain except for tail
\node[on chain] (dummy) {};
\node[list,on chain] (A) {43 \nodepart{two} Inge}; 
\node[list,on chain] (B) {18 \nodepart{two} Jessica};
\node[list,on chain] (C) {37 \nodepart{two} Karin};
\node[list,on chain] (D) {14 \nodepart{two} Janet};
\node[headtail,below=of dummy,yshift=-0.5cm] (head) {\phantom{head}};
\node[headtail,below=of B.two,yshift=-0.5cm] (current) {\phantom{current}};
\node[headtail,below=of C.three,yshift=-0.5cm] (tail) {\phantom{current}};

% The null-pointer cross
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt] (D.north east) -- (D.two split south);
\draw[line cap=round, shorten >=.6pt, shorten <=.99pt]  (D.south east) -- (D.two split north);

% The connecting arrows
\draw[dotarrow] (A.three |- A.center) -- (B);
\draw[dotarrow] (B.three |- B.center) -- (C);
\draw[dotarrow] (C.three |- C.center) -- (D);
\draw[fill=black] (head.center) circle (0.08);
\draw[-latex] (head.center) to[bend right] (A.one south);
\draw[fill=black] (current.center) circle (0.08);
\draw[-latex,dashed] (current.center) to[bend right] (C.one south);
\draw[fill=black] (tail.center) circle (0.08);
\draw[-latex,dashed] (tail.center) to[bend right] (D.one south);

\node[yshift=\unitsize cm] at (head.center) {head};
\node[yshift=\unitsize cm] at (current.center) {current};
\node[yshift=\unitsize cm] at (tail.center) {current@end};

\node[yshift=.3cm] at (A.two north) {$A$};
\node[yshift=.3cm] at (B.two north) {$B$};
\node[yshift=.3cm] at (C.two north) {$C$};
\node[yshift=.3cm] at (D.two north) {$D$};
   
\end{tikzpicture}
\caption{Het vinden van het einde van de linked list.}
\label{fig:strstrfindingendoflist}
\end{figure}

In eerste instantie wordt pointer \lstc{current} gelijk gesteld aan \lstc{head}. Dat is namelijk het begin van de linked list. We schrijven dus:

\begin{lstlisting}[style=lstoneline]
current = head;
\end{lstlisting}

%\booklistingfromproject[linerange={71-71},style=lstoneline,label=dummy40,gobble=8]{C}{}{linked_list_malloc}{c}{H}

Zowel \lstc{head} als \lstc{current} wijzen dus naar node $A$. In de conditie van de \lstc{while}-lus kijken we of er een opvolger is. Om te bepalen of er een opvolger is, testen we de member \lstc{next} van de pointer \lstc{current}. Dus we schrijven:

\begin{lstlisting}[style=lstoneline]
while (current->next != NULL) {
    ...
}
\end{lstlisting}

Als er een opvolger is dan springen we naar de opvolger. Dit doen we door gebruik te maken van member \lstc{next}:

\begin{lstlisting}[style=lstoneline]
current = current->next;
\end{lstlisting}

Dus als \lstc{current} wijst naar $A$ wordt de nieuwe waarde $A$\lstc{->next} oftwel $B$.
De pointer \lstc{current} wijst na het uitvoeren van het statement naar $B$. Uiteindelijk is de laatste node in de linked list gevonden en wijst \lstc{current} naar node $D$. Dit is weergegeven met de (pseudo)-pointer \lstc{current@end}. Daarna laten we deze laatste node $D$ wijzen naar de nieuwe node. Dat doen we met het statement

\begin{lstlisting}[style=lstoneline]
current->next = created;
\end{lstlisting}

Vervolgens moeten we de nieuwe node vullen met gegevens. We kopiëren de leeftijd en de naam naar de nieuwe node en zetten gelijk de member \lstc{next} op \lstc{NULL} want de nieuwe node heeft geen opvolger.

\begin{lstlisting}[style=lstoneline]
created->age = age;
strcpy(created->name, name);
created->next = NULL;
\end{lstlisting}

Als laatste statement geven we als returnwaarde het adres van \lstc{created} terug. Op zich is dat niet zo belangrijk maar we moeten onderscheid maken tussen \lstc{NULL} en een geldig adres, want in \lstc{main} wordt getest of de returnwaarde \lstc{NULL} is of niet.

\begin{lstlisting}[style=lstoneline]
return created;
\end{lstlisting}

De functie \lstc{print_all_nodes} is kort en krachtig. De functie is te zien in listing~\ref{cod:strprintallnodes}. De functie heeft geen parameters en geeft niets terug.  We gebruiken hier een \lstc{while}-lus om langs alle nodes te gaan totdat we het einde van de linked list hebben bereikt. We beginnen met het initialiseren van de pointer \lstc{current} met \lstc{head}. Daar moeten we tenslotte beginnen. In de \lstc{while}-lus wordt getest of \lstc{current} niet naar \lstc{NULL} wijst. Dan is er nog een node waarvan de gegevens moeten worden afgedrukt. In de lus laten we \lstc{current} naar de volgende node wijzen. 

\booklistingfromproject[linerange={93-105},label=cod:strprintallnodes]{C}{De functie \lstc{print_all_nodes}}{linked_list_malloc}{c}{!ht}

Voordat het programma wordt afgesloten, moeten de gealloceerde nodes eerst weer worden vrijgegeven. Dat kan met de functie \lstc{remove_all_nodes}. De functie is te zien in listing~\ref{cod:strremoveallnodes}. We beginnen met het verwijderen bij het begin van de linked list, dus waar de pointer \lstc{head} naar wijst. We verwijderen de node met de functie \lstc{free} en laten \lstc{head} naar de volgende in de linked list wijzen. We doen dit totdat de laatste node is verwijderd.

Er zit nog wel een bepaalde volgorde in het verwijderen van een node en het laten wijzen van \lstc{head} naar de volgende in de linked list. We moeten \lstc{head} eerst laten wijzen naar de volgende node en dan pas de (eerdere) node verwijderen. Dat kan natuurlijk niet met \lstc{head} want die wijst al naar de volgende node. Daarom gebruiken we een extra variabele \lstc{remnode} die naar de te verwijderen node wijst.

\booklistingfromproject[linerange={107-120},label=cod:strremoveallnodes]{C}{De functie \lstc{remove_all_nodes}}{linked_list_malloc}{c}{!ht}

Overigens kunnen we het verwijderen van de nodes in dit programma achterwege laten. Als het programma is afgesloten, wordt al het gealloceerde geheugen automatisch door het besturingssysteem vrijgegeven.

Een mogelijke invoer en uitvoer is hieronder gegeven.

\begin{dosbox}[title=Mogelijke invoer en uitvoer van het programma.]
Give age (> 0): (*\textbf{54}*)
Give name: (*\textbf{Harry}*)
Give age (> 0): (*\textbf{23}*)
Give name: (*\textbf{Klara}*)
Give age (> 0): (*\textbf{45}*)
Give name: (*\textbf{Gerard}*)
Give age (> 0): (*\textbf{28}*)
Give name: (*\textbf{Joyce}*)
Give age (> 0): (*\textbf{0}*)
Age: 54, name: Harry
Age: 23, name: Klara
Age: 45, name: Gerard
Age: 28, name: Joyce
\end{dosbox}

We kunnen nog wat zeggen over de efficiëntie van enkele acties op de linked list. Als we een node toevoegen moeten we eerst het einde van de linked list bepalen. We moeten dus alle nodes aflopen. We noemen deze \textsl{tijdcomplexiteit} ``van de orde $n$'' en wordt geschreven $O(n)$. Als we een node net een specifieke inhoud moeten verwijderen (overigens niet in het voorbeeld gegeven) dan moeten we ten hoogste alle nodes aflopen. Ook deze actie is van de orde $O(n)$. Om dezelfde reden is opzoeken of wijzigen van een node ook van de orde $O(n)$.

\begin{table}[!ht]
\begin{tabular}{lp{1em}l}
Actie && Orde \\
\midrule
Toevoegen && $O(n)$ \\
Verwijderen && $O(n)$ \\
Opzoeken && $O(n)$ \\
Wijzigen && $O(n)$
\end{tabular}
\end{table}
\basic

We kunnen het toevoegen ook anders realiseren. In plaats van het einde van de linked list steeds opnieuw op te zoeken, kunnen een nieuwe node ook aan het \textsl{begin} van de linked list toevoegen. Dat begin is direct te vinden want daarvoor gebruiken we de pointer \lstc{head}. We maken een nieuwe node aan, laten de member \lstc{next} wijzen naar \lstc{head} en laten daarna \lstc{head} wijzen naar de nieuwe node. Nu is deze functie van de orde $O(1)$.

Overigens is de linked list niet gesorteerd. Dat heeft ook alleen maar zin als we de linked list gesorteerd willen afdrukken. Voor het opzoeken en verwijderen van een node maakt het niet veel uit.

Als we gebruik willen maken van een gesorteerde linked list, bijvoorbeeld van woorden, dan kunnen we beter gebruik maken van een \textsl{binaire boom} (Engels: binary tree). Tijdens het toevoegen van een node kan de sortering dan efficiënt worden gerealiseerd. De eerder gegeven acties zijn dan \textsl{gemiddeld} van de orde $O(\log n)$ en in het slechtste geval $O(n)$. Het valt echter buiten de scope van dit boek. Er is veel literatuur te vinden over binaire bomen. 