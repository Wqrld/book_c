\chapter{Invoer en uitvoer}
\label{cha:io}
\thispagestyle{empty}

\section{Inlezen van een getal met \texttt{scanf}}
\label{sec:scanf}
De functie \texttt{scanf} is een veelzijdige functie voor het inlezen van variabelen. Zo kan je een getal, een letter of een string inlezen. Maar hoe weet \texttt{scanf} nu wat er ingelezen moet worden? Dat geven we op met een format string. Een enkel geheel getal wordt inlezen met:

\hspace*{1em}\texttt{scanf("\%d", \&getal);}

De format specification \texttt{\%d} vertelt \texttt{scanf} dat een geheel getal moet worden ingelezen. De variabele waarin het getal moet komen te staan, wordt voorzien van de adres-operator \texttt{\&}\indextwo{\&}{operator} zodat \texttt{scanf} de variabele kan vinden.
Het is ook mogelijk om meerdere getallen in te lezen:

\hspace*{1em}\texttt{scanf("\%d \%d \%d", \&getala, \&getalb, \&getalc);}

Bij het invoeren moeten de getallen gescheiden worden door \'e\'en of meerdere spaties. Het aantal spaties\index{spatie} maakt dus niet uit; deze worden overgeslagen.

We kunnen ook andere datatypes inlezen zoals een \texttt{float} of een \texttt{char}

\hspace*{1em}\texttt{scanf("\%f \%c", \&fl, \&ch);}





\subsection{Problemen met \texttt{scanf}}

Als we in een C-programma een getal inlezen met \lstinline|scanf| dan gebeuren er vreemde dingen als we in plaats van een getal letters intypen. Bijvoorbeeld:

\begin{figure}[H]
\begin{lstlisting}[caption=Getal inlezen met \texttt{scanf}.]
#include <stdio.h>

int main(void) {
    int getal = -12345;

    printf("Geef een geheel getal: ");
    scanf("%d", &getal);

    printf("Het getal is %d.\n", getal);

    return 0;
}
\end{lstlisting}
\end{figure}

Als we dit programma uitvoeren en als invoer het woord \texttt{Hallo} intypen dan verschijnt de volgende uitvoer:

\begin{dosbox}
Geef een geheel getal: Hallo\\
Het getal is -12345.
\end{dosbox}

Het blijkt dat de waarde van variabele \texttt{getal} niet is veranderd. Het eerste teken dat \texttt{scanf} tegenkomt is de \texttt{H} en dat is geen cijfer, dus wordt er gestopt met inlezen van het toetsenbord. Het wordt echt problematisch als er een getal ingelezen moet worden dat aan een voorwaarde moet voldoen:

\begin{figure}[!ht]
\begin{lstlisting}[caption=Het inlezen van een geheel getal dat groter is dan 0.]
int main(void) {
    int getal = -12345;

    do {
        printf("Geef een geheel getal groter dan 0: ");
        scanf("%d", &getal);
    } while (getal < 1);

    printf("Het getal is %d.\n", getal);
    return 0;
}
\end{lstlisting}
\end{figure}


De uitvoer is nu:

\begin{dosbox}
Geef een geheel getal groter dan 0: Hallo\\
Geef een geheel getal groter dan 0: Geef een geheel getal groter dan\\
0: Geef een geheel getal groter dan 0: Geef een geheel getal groter \\
dan 0: Geef een geheel getal groter dan 0: Geef een geheel getal gro\\
ter dan 0: Geef een geheel getal groter dan 0: Geef een geheel getal\\
\bfseries\textsl{\textrm{enzovoorts}}
\textbf{}\end{dosbox}

Het programma gaat nu als een razende te werk en de enige manier om het te stoppen is het programma af te sluiten. Maar hoe komt dat nou?

%\subsubsection*{Buffering}
Als \texttt{scanf} voor de eerste keer iets inleest dan zijn er nog geen karakters vanaf het toetsenbord ingevoerd. Daarom vraagt \texttt{scanf} aan het besturingssysteem (Windows, Linux, OS-X) om een karakter. Het besturingssysteem weet dat er geen karakters beschikbaar zijn en gaat via interne routines karakters opvragen. Er wordt echter niet \'e\'en karakter opgevraagd maar een hele reeks die afgesloten moet worden met een \texttt{enter}-toets. We moeten als gebruiker dus de invoer altijd afsluiten met een \texttt{enter}-toets, ook als we via \texttt{scanf} maar \'e\'en karakter inlezen. De ingelezen karakters worden ergens in het geheugen opgeslagen. Dit wordt \textsl{buffering}\index{buffering} genoemd en de geheugenruimte wordt \textsl{invoerbuffer}\index{invoerbuffer} genoemd. Er zijn nu karakters beschikbaar en het eerste ingevoerde karakter wordt aan \texttt{scanf} gegeven.

Het eerste karakter is de letter \texttt{H} en dat is geen cijfers. Dus stopt \texttt{scanf} direct met het inlezen van karakters (die dus alleen cijfers mogen zijn). Het karakter \texttt{H} blijft hierbij in de invoerbuffer staan. De \texttt{H} wordt dus niet verwijderd.

Omdat \texttt{scanf} geen cijfers heeft kunnen inlezen, wordt de opgegeven variabele niet veranderd en blijft zijn originele waarde behouden. Daarom drukt het programma in listing~\ref{}het getal $-12345$ af. Het programma in listing~\ref{} blijft in een \texttt{do-while}-lus steeds een getal inlezen als het getal kleiner is dan~$-1$. Aangezien \texttt{scanf} geen cijfers inleest en de opgegeven variabele niet aanpast, blijft de waarde $-12345$ behouden en dat is kleiner dan $-1$. Dus wordt de lus nog een keer uitgevoerd. De \texttt{H} staat nog steeds in de invoerbuffer en lukt het \texttt{scanf} niet om een getal in te lezen.

Dit kun je vrij eenvoudig voorkomen door de returnwaarde van de functie \lstinline|scanf| te testen. Deze functie geeft het aantal variabelen terug dat succesvol is geconverteerd en ingelezen (dat kan dus ook 0 zijn), anders geeft de functie de integer waarde \lstinline|EOF| terug. Je kan dat als volgt doen:

\begin{lstlisting}
#include <stdio.h>

int main(void) {
int getal = -12345;
int ret;

printf("Geef een geheel getal groter dan 0: ");
ret = scanf("%d", &getal);

if (ret == 1) {
printf("Het getal is %d.\n", getal);
} else {
printf("Geen getal ingevoerd!\n");
}

printf("Druk op de Enter toets om dit window te sluiten.");
getchar();
return 0;
}
\end{lstlisting}

De uitvoer wordt dan:

\begin{lstlisting}[language=,literate=]
Geef een geheel getal groter dan 0: Hallo
Geen getal ingevoerd!
Druk op de Enter toets om dit window te sluiten.
\end{lstlisting}

Er is nog \'e\'en probleem. De karakters van \lstinline|Hallo| staan nog steeds in de invoerbuffer. Die zullen we er een voor een uit moeten halen. Dat kan met het onderstaande programma:

\begin{lstlisting}
#include <stdio.h>

int main(void) {
int getal, ret;
do {
printf("Geef een geheel getal: ");
ret=scanf("%d", &getal);
if (ret == 0) {
printf("Dat was geen getal!\n");
printf("Maar het karakter %c.\n", getchar());
}
else if (ret == EOF) {
printf("Er is een fout opgetreden bij het lezen!\n");
}
} while (ret != 1);
printf("Het getal is %d.\n", getal);
printf("Druk op de Enter toets om dit window te sluiten.");
getchar();
return 0;
}

\end{lstlisting}

De functie \lstinline|getchar| leest \'e\'en karakter uit de invoerbuffer. Daarna proberen we \lstinline|scanf| opnieuw. Dat mislukt telkens als er een letter gevonden wordt. Als je nu \lstinline|Hallo| invoert, krijg je de volgende uitvoer:

\begin{lstlisting}[language=,literate=]
Geef een geheel getal: Hallo
Dat was geen getal!
Maar het karakter H.
Geef een geheel getal: Dat was geen getal!
Maar het karakter a.
Geef een geheel getal: Dat was geen getal!
Maar het karakter l.
Geef een geheel getal: Dat was geen getal!
Maar het karakter l.
Geef een geheel getal: Dat was geen getal!
Maar het karakter o.
Geef een geheel getal:
\end{lstlisting}

Natuurlijk willen niet steeds dat bij elk karakter een melding op het scherm wordt afgedrukt. We kunnen een aantal \lstinline|printf|-regels verwijderen maar niet de regel waarin de gebruiker wordt gevraagd om een geheel getal in te voeren. Anders weet de gebruiker niet wat hij/zij moet doen. Helaas wordt deze regel herhaaldelijk afgedrukt. We zullen op een iets andere manier de karakters moeten inlezen.

Gelukkig zorgt het operating system ervoor dat ook het end-of-line-karakter in de invoerbuffer terecht komt. We kunnen dus hierop testen. Hoe dat moet, is te zien in de onderstaande code:

\begin{lstlisting}
do { ch = getchar(); } while (ch != '\n' && ch != EOF);
\end{lstlisting}

We lezen een karakter van de invoerbuffer en dat doen we zolang dat karakter ongelijk is aan \lstinline|\n| (end-of-line-karakter) en ongelijk is aan \lstinline|EOF| (end-of-file).

Omdat we vaker gebruik willen maken van het legen van de invoerbuffer plaatsen we de code een functie. We kunnen nu aan de gebruiker vragen om een getal in te voeren:

\begin{lstlisting}
#include <stdio.h>

void purge_stdin(void) {
int ch;
do {
ch = getchar();
} while (ch != '\n' && ch != EOF);
}

int main(void) {
int getal, ret;
do {
printf("Geef een geheel getal: ");
ret=scanf("%d", &getal);
if (ret == 0) {
purge_stdin();
}
} while (ret != 1);
printf("Het getal is %d.\n", getal);
printf("Druk op de Enter toets om dit window te sluiten.");
purge_stdin();
getchar();
return 0;
}
\end{lstlisting}

Er is nog een andere manier om de invoerbuffer te legen. We kunnen de invoerbuffer legen met de functie \lstinline|fflush| (file flush):

\begin{lstlisting}
fflush(stdin);
\end{lstlisting}

Als parameter van \lstinline|fflush| wordt \lstinline|stdin| opgegeven. Dat staat voor \textsl{standard input} en daar wordt in de regel het toetsenbord mee bedoeld\footnote{Op de bekende operating systems is het mogelijk om de inhoud van bestanden door te geven aan de \textsl{standard input}. Het programma krijgt dan data uit een bestand i.p.v.\@ het toetsenbord. Dat wordt \textsl{redirection} genoemd.}. Daarnaast kennen we nog \lstinline|stdout| (\textsl{standard output}, het beeldscherm) en \lstinline|stderr| (\textsl{standard error}, meestal ook het beeldscherm).

\textbf{Deze manier werkt echter niet met alle C-compilers en operating systems}. Dat heeft te maken met de definitie van de functie \lstinline|fflush|. De functie \lstinline|fflush| is bedoeld om uitvoerbuffers te legen. Als de uitvoer naar het beeldscherm is, wordt de buffer naar het beeldscherm geschreven. Als de uitvoer naar een bestand is, wordt de buffer naar het bestand geschreven. De C-standaard schrijft echter alleen voor dat \textsl{flushen} van een uitvoerbuffer gedefinieerd is, niet van een invoerbuffer. Niet zo gek eigenlijk, want wat wordt er nou bedoeld met flushen van de invoerbuffer. Flushen van het toetsenbord is het nog te begrijpen maar flushen van een invoerbestand niet. Moeten we dan helemaal tot einde van het bestand flushen? Of alleen maar de bijbehorende buffer? Dat levert een onvoorspelbaar programma op want we weten immers niet hoeveel karakters in de buffer staan.

Toch zijn er wel C-implementaties die het flushen van een invoerbuffer uitvoeren, bijvoorbeeld de GNU C-compiler op Linux en MinGW op Windows (zit o.a.\@ in Code::Blocks).

Hieronder is de code te vinden van het flushen van de invoerbuffer van het toetsenbord m.b.v.\@ \lstinline|fflush|:

\newpage
\begin{lstlisting}
/* Please note: might not works on all Operating Systems. */
#include <stdio.h>

int main(void) {
int getal, ret;
do {
printf("Geef een geheel getal: ");
ret=scanf("%d", &getal);
if (ret == 0) {
fflush(stdin);
}
} while (ret != 1);
printf("Het getal is %d.\n", getal);
printf("Druk op de Enter toets om dit window te sluiten.");
fflush(stdin);
getchar();
return 0;
}
\end{lstlisting}

